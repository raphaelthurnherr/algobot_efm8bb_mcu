C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/02/2018 00:35:21 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\Raph\Go
                    -ogle Drive\dev\embedded_soft\efm8bb\algobot_efm8bb_mcu\V1\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARN
                    -INGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:/Users/Raph/Google Dri
                    -ve/dev/embedded_soft/efm8bb/algobot_efm8bb_mcu/V1/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.2//Dev
                    -ice/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.2//Device/EFM8BB1/inc) PRINT(.\src\Int
                    -errupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          #define CAPTURE_CLOCK_PERIODE_US        0.4898
  10          #define SOUND_SPEED_MM_US                       0.34029
  11          
  12          // USER INCLUDES
  13          #include <SI_EFM8BB1_Register_Enums.h>
  14          #include"algo_sensor_processing.h"
  15          #include"func.h"
  16          
  17          
  18          // I2C variables
  19          uint8_t NUM_BYTES_WR = 1;
  20          uint8_t NUM_BYTES_RD = 1;
  21          
  22          //-----------------------------------------------------------------------------
  23          // SMBUS0_ISR
  24          //-----------------------------------------------------------------------------
  25          //
  26          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  27          // SMB0CN0::SI (SMBus Interrupt Flag)
  28          //
  29          //-----------------------------------------------------------------------------
  30          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  31          {
  32   1              static uint8_t sent_byte_counter;
  33   1              static uint8_t rec_byte_counter;
  34   1      
  35   1      
  36   1              if (SMB0CN0_ARBLOST == 0)
  37   1              {
  38   2                      switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
  39   2                      {
  40   3                      // Slave Receiver: Start+Address received
  41   3                              case SMB_SRADD:
  42   3                                      SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit
  43   3      
  44   3                                      sent_byte_counter = 1;// Reinitialize the data counters
  45   3                                      rec_byte_counter = 1;
  46   3      
  47   3                                      if ((SMB0DAT & 0xFE) == (SLAVE_ADDR & 0xFE))// Decode address
  48   3                                      {                                                               // If the received address matches,
  49   4                                              SMB0CN0_ACK = 1;                                                // SMB0CN0_ACK the received slave address
  50   4      
  51   4      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/02/2018 00:35:21 PAGE 2   

  52   4                                              if ((SMB0DAT & 0x01) == READ)                   // If the transfer is a master READ,
  53   4                                              {
  54   5                                                      // Prepare outgoing byte
  55   5                                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
  56   5                                                      //SMB0DAT = getRegisterValue(SMB_DATA_IN[0]);
  57   5                                                      sent_byte_counter++;
  58   5                                                      //I2C_SET_REGISTER=0;
  59   5                                                      NUM_BYTES_WR=1;
  60   5                                              }
  61   4                                              else{
  62   5                                                      NUM_BYTES_WR=1;
  63   5                                                      //I2C_SET_REGISTER=1;
  64   5                                              }
  65   4                                      }
  66   3                                      else                       // If received slave address does not
  67   3                                      {                          // match,
  68   4                                              SMB0CN0_ACK = 0;                // NACK received address
  69   4                                      }
  70   3                                      break;
  71   3      
  72   3                      // Slave Receiver: Data received
  73   3                              case SMB_SRDB:
  74   3      
  75   3                                      SMB0CN0_ACK = 1;                        // SMB0CN0_ACK received data
  76   3      
  77   3                                      // Store incoming data
  78   3                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
  79   3      
  80   3                                      if (rec_byte_counter < NUM_BYTES_WR)
  81   3                                              rec_byte_counter++;
  82   3                                      else
  83   3                                              I2C_DATA_READY = 1;                     // Indicate new data fully received
  84   3                                      break;
  85   3      
  86   3                      // Slave Receiver: Stop received while either a Slave Receiver or
  87   3                      // Slave Transmitter
  88   3                              case SMB_SRSTO:
  89   3                                      SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
  90   3                                                                      // a STOP is detected as a slave
  91   3                                      break;
  92   3      
  93   3                      // Slave Transmitter: Data byte transmitted
  94   3                              case SMB_STDB:
  95   3      
  96   3                                      if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
  97   3                                      {
  98   4                                              if (sent_byte_counter <= NUM_BYTES_RD)
  99   4                                              {
 100   5                                                      // Prepare next outgoing byte
 101   5                                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 102   5                                                      sent_byte_counter++;
 103   5                                              }
 104   4                                      }                          // Otherwise, do nothing
 105   3                                      break;
 106   3      
 107   3                      // Slave Transmitter: Arbitration lost, Stop detected
 108   3                      //
 109   3                      // This state will only be entered on a bus error condition.
 110   3                      // In normal operation, the slave is no longer sending data or has
 111   3                      // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
 112   3                      // bit is cleared and the slave goes to the SRSTO state.
 113   3                      case SMB_STSTO:
 114   3      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/02/2018 00:35:21 PAGE 3   

 115   3                                      SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
 116   3                                                                      // a STOP is detected as a slave
 117   3                                      NUM_BYTES_WR=1;
 118   3                                      break;
 119   3      
 120   3                      // Default: all other cases undefined
 121   3                              default:
 122   3      
 123   3                              SMB0CF &= ~0x80;// Reset communication
 124   3                              SMB0CF |= 0x80;
 125   3                              SMB0CN0_STA = 0;
 126   3                              SMB0CN0_STO = 0;
 127   3                              SMB0CN0_ACK = 0;
 128   3                              NUM_BYTES_WR=1;
 129   3                              break;
 130   3                      }
 131   2              }
 132   1              // ARBLOST0 = 1, Abort failed transfer
 133   1              else
 134   1              {
 135   2                      SMB0CN0_STA = 0;
 136   2                      SMB0CN0_STO = 0;
 137   2                      SMB0CN0_ACK = 0;
 138   2                      NUM_BYTES_WR=1;
 139   2              }
 140   1      
 141   1              SMB0CN0_SI = 0;                             // Clear SMBus interrupt flag
 142   1      }
 143          
 144          //-----------------------------------------------------------------------------
 145          // ADC0EOC_ISR
 146          //-----------------------------------------------------------------------------
 147          //
 148          // ADC0EOC ISR Content goes here. Remember to clear flag bits:
 149          // ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
 150          //
 151          //-----------------------------------------------------------------------------
 152          SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
 153          {
 154   1              float meaning;
 155   1              unsigned char i;
 156   1              unsigned int ADC_DATA = 0;
 157   1              static unsigned int ADC_ACC[10];
 158   1              static unsigned char ptr=0;
 159   1      
 160   1              ADC_DATA = ADC0H;
 161   1              ADC_DATA = ADC_DATA<<8 | ADC0L;
 162   1      
 163   1              // Enregistrement de la nouvelle valeur ADC en écrasant la plus ancienne
 164   1              if(ptr>=10)
 165   1              ptr=0;
 166   1      
 167   1              ADC_ACC[ptr] = ADC_DATA;
 168   1              ptr++;
 169   1      
 170   1              // REALISATION DE LA MOYENNE DE TENSION
 171   1              meaning=0;
 172   1              for(i=0;i<10;i++) {
 173   2                      meaning += ADC_ACC[i];
 174   2              }
 175   1      
 176   1              //Réalisation de la moyenne, conversion en V et compensation du diviseur de tension
 177   1              meaning = (meaning/10) *ADC_RES_MV * 1.81481;   // (R1+R2)/R2
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/02/2018 00:35:21 PAGE 4   

 178   1              //meaning = (meaning/10) *ADC_RES_MV * 5.5454;   // (R1+R2)/R2   POUR CARTE Version 1
 179   1              // Enregistrement de la moyenne en mV
 180   1              BATTERY.voltage_mean_mV= meaning*1000;
 181   1      
 182   1              ADC0CN0_ADINT=0;// Reset le flag d'interruption
 183   1      }
 184          
 185          //-----------------------------------------------------------------------------
 186          // TIMER3_ISR
 187          //-----------------------------------------------------------------------------
 188          //
 189          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 190          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 191          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 192          //
 193          //-----------------------------------------------------------------------------
 194          
 195          // INTERRUPTION TIMER @ 10uS
 196          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 197          {
 198   1              static sonarWaitEchoStart=0;
 199   1      
 200   1              static int counter_100mS = 0;
 201   1      
 202   1              // Génère une pulse de 10uS pour démarrer la mesure sur le capteur
 203   1      
 204   1              // Signal de début de mesure
 205   1              if(StartSonarMeasure==1){
 206   2                      if(!SONAR_TRIG_PIN){
 207   3                              SONAR_TRIG_PIN = 1;
 208   3                      }
 209   2                      else {
 210   3                              SONAR_TRIG_PIN = 0;
 211   3                              StartSonarMeasure=0;
 212   3                              sonarWaitEchoStart=1;
 213   3                      }
 214   2              }
 215   1      
 216   1              // Attend le début de l'echo sur un niveau haut
 217   1              if(sonarWaitEchoStart){
 218   2                      if(SONAR_ECHO_PIN){
 219   3                              TMR2L=TMR2H=0;          // Reset le registre Timer 2 utilisé pour mesure la largeur d'impulsion
 220   3                              sonarWaitEchoStart=0;
 221   3                      }
 222   2              }
 223   1      
 224   1              if(counter_100mS >= 2000) {
 225   2                      TICK_100MS = 1;                 // Active le flag 100mS du programme principale.
 226   2                      counter_100mS = 0;
 227   2              }
 228   1      
 229   1              // INCREMENTE LES COMPTEURS DE 1mS
 230   1              counter_100mS++;
 231   1      
 232   1              TMR3CN0 &= 0x3F;// Reset les flags d'interruption Low et High timer3
 233   1      }
 234          
 235          
 236          //-----------------------------------------------------------------------------
 237          // TIMER2_ISR
 238          //-----------------------------------------------------------------------------
 239          //
 240          // TIMER2 ISR Content goes here. Remember to clear flag bits:
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/02/2018 00:35:21 PAGE 5   

 241          // TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
 242          // TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
 243          //
 244          //-----------------------------------------------------------------------------
 245          
 246          SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
 247          {
 248   1              float capture_time_us=0;
 249   1              unsigned char i;
 250   1              long meaning_data;
 251   1              static unsigned int DATA_ACC[10];
 252   1              static unsigned char ptr=0;
 253   1              int meaning_uS;
 254   1      
 255   1              // Enregistrement de la nouvelle valeur ADC en écrasant la plus ancienne
 256   1              if(ptr>=10)
 257   1              ptr=0;
 258   1      
 259   1              DATA_ACC[ptr] = TMR2;
 260   1      
 261   1              // REALISATION DE LA MOYENNE DE TENSION
 262   1              meaning_data=0;
 263   1              for(i=0;i<10;i++) {
 264   2                      meaning_data += DATA_ACC[i];
 265   2              }
 266   1      
 267   1              // Réalisation d'une moyenne sur n mesures
 268   1              meaning_data = (meaning_data/10);
 269   1              meaning_uS =  meaning_data * CAPTURE_CLOCK_PERIODE_US;
 270   1              //meaning_uS =  meaning_data * CAPTURE_CLOCK_PERIODE_US * SOUND_SPEED_MM_US /2;
 271   1      
 272   1              SONAR.dist_inst_mm = DATA_ACC[ptr] * CAPTURE_CLOCK_PERIODE_US * SOUND_SPEED_MM_US /2;
 273   1              SONAR.dist_mean_mm = meaning_uS * SOUND_SPEED_MM_US /2;
 274   1      
 275   1              ptr++;
 276   1      
 277   1              TMR2CN0_TF2H=0;
 278   1              TMR2CN0_TF2L=0;
 279   1      }
 280          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    783    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
