//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

#define CAPTURE_CLOCK_PERIODE_US	0.4898
#define SOUND_SPEED_MM_US			0.34029

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>
#include"algo_sensor_processing.h"
#include"func.h"


// I2C variables
uint8_t NUM_BYTES_WR = 1;
uint8_t NUM_BYTES_RD = 1;

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{
	static uint8_t sent_byte_counter;
	static uint8_t rec_byte_counter;


	if (SMB0CN0_ARBLOST == 0)
	{
		switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
		{
		// Slave Receiver: Start+Address received
			case SMB_SRADD:
				SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit

				sent_byte_counter = 1;// Reinitialize the data counters
				rec_byte_counter = 1;

				if ((SMB0DAT & 0xFE) == (SLAVE_ADDR & 0xFE))// Decode address
				{                          					// If the received address matches,
					SMB0CN0_ACK = 1;						// SMB0CN0_ACK the received slave address


					if ((SMB0DAT & 0x01) == READ)			// If the transfer is a master READ,
					{
						// Prepare outgoing byte
						SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
						//SMB0DAT = getRegisterValue(SMB_DATA_IN[0]);
						sent_byte_counter++;
						//I2C_SET_REGISTER=0;
						NUM_BYTES_WR=1;
					}
					else{
						NUM_BYTES_WR=1;
						//I2C_SET_REGISTER=1;
					}
				}
				else                       // If received slave address does not
				{                          // match,
					SMB0CN0_ACK = 0;		// NACK received address
				}
				break;

		// Slave Receiver: Data received
			case SMB_SRDB:

				SMB0CN0_ACK = 1;			// SMB0CN0_ACK received data

				// Store incoming data
				SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;

				if (rec_byte_counter < NUM_BYTES_WR)
					rec_byte_counter++;
				else
					I2C_DATA_READY = 1;			// Indicate new data fully received
				break;

		// Slave Receiver: Stop received while either a Slave Receiver or
		// Slave Transmitter
			case SMB_SRSTO:
				SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
								// a STOP is detected as a slave
				break;

		// Slave Transmitter: Data byte transmitted
			case SMB_STDB:

				if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
				{
					if (sent_byte_counter <= NUM_BYTES_RD)
					{
						// Prepare next outgoing byte
						SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
						sent_byte_counter++;
					}
				}                          // Otherwise, do nothing
				break;

		// Slave Transmitter: Arbitration lost, Stop detected
		//
		// This state will only be entered on a bus error condition.
		// In normal operation, the slave is no longer sending data or has
		// data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
		// bit is cleared and the slave goes to the SRSTO state.
		case SMB_STSTO:

				SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
								// a STOP is detected as a slave
				NUM_BYTES_WR=1;
				break;

		// Default: all other cases undefined
			default:

			SMB0CF &= ~0x80;// Reset communication
			SMB0CF |= 0x80;
			SMB0CN0_STA = 0;
			SMB0CN0_STO = 0;
			SMB0CN0_ACK = 0;
			NUM_BYTES_WR=1;
			break;
		}
	}
	// ARBLOST0 = 1, Abort failed transfer
	else
	{
		SMB0CN0_STA = 0;
		SMB0CN0_STO = 0;
		SMB0CN0_ACK = 0;
		NUM_BYTES_WR=1;
	}

	SMB0CN0_SI = 0;                             // Clear SMBus interrupt flag
}

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
{
	float meaning;
	unsigned char i;
	unsigned int ADC_DATA = 0;
	static unsigned int ADC_ACC[10];
	static unsigned char ptr=0;

	ADC_DATA = ADC0H;
	ADC_DATA = ADC_DATA<<8 | ADC0L;

	// Enregistrement de la nouvelle valeur ADC en écrasant la plus ancienne
	if(ptr>=10)
	ptr=0;

	ADC_ACC[ptr] = ADC_DATA;
	ptr++;

	// REALISATION DE LA MOYENNE DE TENSION
	meaning=0;
	for(i=0;i<10;i++) {
		meaning += ADC_ACC[i];
	}

	//Réalisation de la moyenne, conversion en V et compensation du diviseur de tension
	meaning = (meaning/10) *ADC_RES_MV * 1.81481;   // (R1+R2)/R2
	//meaning = (meaning/10) *ADC_RES_MV * 5.5454;   // (R1+R2)/R2   POUR CARTE Version 1
	// Enregistrement de la moyenne en mV
	BATTERY.voltage_mean_mV= meaning*1000;

	ADC0CN0_ADINT=0;// Reset le flag d'interruption
}

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------

// INTERRUPTION TIMER @ 10uS
SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
{
	static sonarWaitEchoStart=0;

	static int counter_100mS = 0;

	// Génère une pulse de 10uS pour démarrer la mesure sur le capteur

	// Signal de début de mesure
	if(StartSonarMeasure==1){
		if(!SONAR_TRIG_PIN){
			SONAR_TRIG_PIN = 1;
		}
		else {
			SONAR_TRIG_PIN = 0;
			StartSonarMeasure=0;
			sonarWaitEchoStart=1;
		}
	}

	// Attend le début de l'echo sur un niveau haut
	if(sonarWaitEchoStart){
		if(SONAR_ECHO_PIN){
			TMR2L=TMR2H=0;		// Reset le registre Timer 2 utilisé pour mesure la largeur d'impulsion
			sonarWaitEchoStart=0;
		}
	}

	if(counter_100mS >= 2000) {
		TICK_100MS = 1;			// Active le flag 100mS du programme principale.
		counter_100mS = 0;
	}

	// INCREMENTE LES COMPTEURS DE 1mS
	counter_100mS++;

	TMR3CN0 &= 0x3F;// Reset les flags d'interruption Low et High timer3
}


//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------

SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
{
	float capture_time_us=0;
	unsigned char i;
	long meaning_data;
	static unsigned int DATA_ACC[10];
	static unsigned char ptr=0;
	int meaning_uS;

	// Enregistrement de la nouvelle valeur ADC en écrasant la plus ancienne
	if(ptr>=10)
	ptr=0;

	DATA_ACC[ptr] = TMR2;

	// REALISATION DE LA MOYENNE DE TENSION
	meaning_data=0;
	for(i=0;i<10;i++) {
		meaning_data += DATA_ACC[i];
	}

	// Réalisation d'une moyenne sur n mesures
	meaning_data = (meaning_data/10);
	meaning_uS =  meaning_data * CAPTURE_CLOCK_PERIODE_US;
	//meaning_uS =  meaning_data * CAPTURE_CLOCK_PERIODE_US * SOUND_SPEED_MM_US /2;

	SONAR.dist_inst_mm = DATA_ACC[ptr] * CAPTURE_CLOCK_PERIODE_US * SOUND_SPEED_MM_US /2;
	SONAR.dist_mean_mm = meaning_uS * SOUND_SPEED_MM_US /2;

	ptr++;

	TMR2CN0_TF2H=0;
	TMR2CN0_TF2L=0;
}

